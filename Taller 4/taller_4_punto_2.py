# -*- coding: utf-8 -*-
"""Taller 4. Punto 2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xdk2y9LjqjsZItQyzvQXCbYhEKjdgroa
"""

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation

plt.rcParams["animation.html"] = "jshtml"

import seaborn as sns

L = 2
Nx = 100
x = np.linspace(0, L, Nx)
dx = x[1]-x[0]
c = 0.5
dt = 0.01
C = c*dt/dx
T = 2
Nt = int(T / dt)


u_dirichlet = np.zeros((Nt, Nx))
u_neumann = np.zeros((Nt, Nx))
u_periodic = np.zeros((Nt, Nx))


u_dirichlet[0, :] = np.exp(-125 * (x - 0.5)**2)
u_neumann[0, :] = np.exp(-125 * (x - 0.5)**2)
u_periodic[0, :] = np.exp(-125 * (x - 0.5)**2)


for i in range(1, Nt - 1):
    for j in range(1, Nx - 1):
        u_dirichlet[i+1,j] =2*(1 - C**2)*u_dirichlet[i, j] + C**2*(u_dirichlet[i, j+1] + u_dirichlet[i, j-1]) - u_dirichlet[i-1, j]
        u_neumann[i+1,j] =2*(1 - C**2)*u_neumann[i, j] + C**2*(u_neumann[i, j+1] + u_neumann[i, j-1]) - u_neumann[i-1, j]
        u_periodic[i+1,j] =2*(1 - C**2)*u_periodic[i, j] + C**2*(u_periodic[i, j+1] + u_periodic[i, j-1]) - u_periodic[i-1, j]



    u_dirichlet[i+1, 0] = 0
    u_dirichlet[i+1, -1] = 0


    u_neumann[i+1, 0] = u_neumann[i+1, 1]
    u_neumann[i+1, -1] = u_neumann[i+1, -2]


    u_periodic[i+1, 0] = u_periodic[i+1, -2]
    u_periodic[i+1, -1] = u_periodic[i+1, 1]



fig, axs = plt.subplots(3, 1, figsize=(8, 8))

lines = []
titles = ['Condiciones Dirichlet','Condiciones Neumann', 'Condiciones Periodicas']
data = [u_dirichlet,u_neumann, u_periodic]

for ax, title in zip(axs, titles):
    ax.set_xlim(0, L)
    ax.set_ylim(-30, 30)
    ax.set_title(title)
    lines.append(ax.plot(x, data[0][0, :])[0])

def animate(n):
    for line, u in zip(lines, data):
        line.set_ydata(u[n, :])
    return lines


plt.tight_layout()
plt.show()

ani = animation.FuncAnimation(fig, animate, frames=Nt, interval=50, blit=True)
ani.save("Onda.gif",fps=30)

ani

"""Punto 4."""

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation

plt.rcParams["animation.html"] = "jshtml"

import seaborn as sns

c = 0.5
xmax = 2
ymax = 1
wx = 0.02
wy = 0.16
dx = 0.02
dy = 0.02
dt = 0.001
nx = int(xmax / dx)
ny = int(ymax / dy)
nt = 500


x = np.linspace(0, xmax, nx)
y = np.linspace(0, ymax, ny)
X, Y = np.meshgrid(x, y)


u0 = 2 * np.exp(-150 * ((X - xmax/5)**2 + (Y - ymax/2)**2))
u = np.copy(u0)
u_prev = np.copy(u0)


obstacle = np.zeros((ny, nx))
obstacle[:, int(nx/2 - wx/dx/2):int(nx/2 + wx/dx/2)] = 1
obstacle[int(ny/2 - wy/dy/2):int(ny/2 + wy/dy/2), int(nx/2 - wx/dx/2):int(nx/2 + wx/dx/2)] = 0

for n in range(1, nt):
    u_next = 2 * u - u_prev + (c * dt)**2 * (
        (np.roll(u, 1, axis=1) - 2 * u + np.roll(u, -1, axis=1)) / dx**2 +
        (np.roll(u, 1, axis=0) - 2 * u + np.roll(u, -1, axis=0)) / dy**2)

    #Condiciones de frontera de Dirichlet
    u_next[0, :] = 0
    u_next[-1, :] = 0
    u_next[:, 0] = 0
    u_next[:, -1] = 0


    u_next[obstacle == 1] = 0


    u_prev = u
    u = u_next



fig, ax = plt.subplots()


im = ax.imshow(u, cmap='inferno', vmin=-2, vmax=2, extent=[0, 2, 0, 1], origin='lower', animated=True)


ax.plot([1, 1], [0.6, 1], color="w", linewidth=10)
ax.plot([1, 1], [0, 0.4], color="w", linewidth=10)

def update(*args):
    global u, u_prev, u_next

    u_next = 2 * u - u_prev + (c * dt)**2 * (
        (np.roll(u, 1, axis=1) - 2 * u + np.roll(u, -1, axis=1)) / dx**2 +
        (np.roll(u, 1, axis=0) - 2 * u + np.roll(u, -1, axis=0)) / dy**2)

    u_next[0, :] = 0
    u_next[-1, :] = 0
    u_next[:, 0] = 0
    u_next[:, -1] = 0
    u_next[obstacle == 1] = 0

    u_prev = u
    u = u_next

    im.set_array(u)
    return [im]

anim = animation.FuncAnimation(fig, update, frames=nt, interval=20, blit=True)
plt.show()

anim.save("bidimensional.gif",fps=30)
anim

for n in range(1, nt):
    u_next = 2 * u - u_prev + (c * dt)**2 * (
        (np.roll(u, 1, axis=1) - 2 * u + np.roll(u, -1, axis=1)) / dx**2 +
        (np.roll(u, 1, axis=0) - 2 * u + np.roll(u, -1, axis=0)) / dy**2)

    # Condiciones de frontera de Neumann
    u_next[0, :] = u_next[1, :]
    u_next[-1, :] = u_next[-2, :]
    u_next[:, 0] = u_next[:, 1]
    u_next[:, -1] = u_next[:, -2]


    u_next[obstacle == 1] = 0


    u_prev = u
    u = u_next


fig, ax = plt.subplots()


im = ax.imshow(u, cmap='inferno', vmin=-2, vmax=2, extent=[0, 2, 0, 1], origin='lower', animated=True)


ax.plot([1, 1], [0.6, 1], color="w", linewidth=10)
ax.plot([1, 1], [0, 0.4], color="w", linewidth=10)

def update(*args):
    global u, u_prev, u_next

    u_next = 2 * u - u_prev + (c * dt)**2 * (
        (np.roll(u, 1, axis=1) - 2 * u + np.roll(u, -1, axis=1)) / dx**2 +
        (np.roll(u, 1, axis=0) - 2 * u + np.roll(u, -1, axis=0)) / dy**2)

    u_next[0, :] = u_next[1, :]
    u_next[-1, :] = u_next[-2, :]
    u_next[:, 0] = u_next[:, 1]
    u_next[:, -1] = u_next[:, -2]

    u_next[obstacle == 1] = 0

    u_prev = u
    u = u_next

    im.set_array(u)
    return [im]

anima = animation.FuncAnimation(fig, update, frames=nt, interval=20, blit=True)
plt.show()

anima.save("bidimensional2.gif",fps=30)
anima

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation


# Parámetros
c = 0.5  # Velocidad de la onda
xmax = 2.0
ymax = 1.0
wx = 0.02  # Ancho de la pared
wy = 0.16  # Ancho de la rendija
dx = 0.02
dy = 0.02
dt = 0.005
nx = int(xmax / dx)
ny = int(ymax / dy)
nt = 500  # Número de pasos temporales

# Mallas espaciales
x = np.linspace(0, xmax, nx)
y = np.linspace(0, ymax, ny)
X, Y = np.meshgrid(x, y)

# Condición inicial
u0 = 2 * np.exp(-150 * ((X - xmax/5)**2 + (Y - ymax/2)**2))
u = np.copy(u0)
u_prev = np.copy(u0)

# Barreras
obstacle = np.zeros((ny, nx))
obstacle[:, int(nx/2 - wx/dx/2):int(nx/2 + wx/dx/2)] = 1
obstacle[int(ny/2 - wy/dy/2):int(ny/2 + wy/dy/2), int(nx/2 - wx/dx/2):int(nx/2 + wx/dx/2)] = 0

# Crear figura para la animación
fig, ax = plt.subplots(figsize=(8, 4))

# Ajustar vmin y vmax para controlar la escala de color
vmin = -1  # Valor mínimo para la escala de color
vmax = 1  # Valor máximo para la escala de color

heatmap = ax.imshow(u, extent=[0, xmax, 0, ymax], origin='lower', cmap='inferno', animated=True, vmin=vmin, vmax=vmax)
plt.colorbar(heatmap, label='Amplitud de la onda')
ax.plot([1,1],[0.6,1 ],color="w",linewidth=10)
ax.plot([1,1],[0,0.4],color="w",linewidth=10)

# Función de actualización para la animación
def update(n):
    global u, u_prev

    # Simulación de la onda
    u_next = 2 * u - u_prev + (c * dt)**2 * (
        (np.roll(u, 1, axis=1) - 2 * u + np.roll(u, -1, axis=1)) / dx**2 +
        (np.roll(u, 1, axis=0) - 2 * u + np.roll(u, -1, axis=0)) / dy**2)

    # Aplicando las condiciones de frontera de Dirichlet
    u_next[0, :] = 0
    u_next[-1, :] = 0
    u_next[:, 0] = 0
    u_next[:, -1] = 0

    # Aplicando la barrera con las rendijas
    u_next[obstacle == 1] = 0

    # Actualización de las matrices
    u_prev = u
    u = u_next

    # Actualizar heatmap
    heatmap.set_array(u)
    return [heatmap]

# Crear la animación
animacion = animation.FuncAnimation(fig, update, frames=nt, blit=True, repeat=False)

# Mostrar la animación
plt.show()

animacion.save("he.gif")
animacion