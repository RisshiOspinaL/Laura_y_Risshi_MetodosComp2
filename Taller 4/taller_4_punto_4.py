# -*- coding: utf-8 -*-
"""Taller 4. Punto 4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1uPZKTE-Ucq27JJAG3K7z0f_zZrScmm6M
"""

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation

plt.rcParams["animation.html"] = "jshtml"

import seaborn as sns

c = 0.5
xmax = 2
ymax = 1
wx = 0.02
wy = 0.16
dx = 0.02
dy = 0.02
dt = 0.001
nx = int(xmax / dx)
ny = int(ymax / dy)
nt = 500


x = np.linspace(0, xmax, nx)
y = np.linspace(0, ymax, ny)
X, Y = np.meshgrid(x, y)


u0 = 2 * np.exp(-150 * ((X - xmax/5)**2 + (Y - ymax/2)**2))
u = np.copy(u0)
u_prev = np.copy(u0)


obstacle = np.zeros((ny, nx))
obstacle[:, int(nx/2 - wx/dx/2):int(nx/2 + wx/dx/2)] = 1
obstacle[int(ny/2 - wy/dy/2):int(ny/2 + wy/dy/2), int(nx/2 - wx/dx/2):int(nx/2 + wx/dx/2)] = 0

for n in range(1, nt):
    u_next = 2 * u - u_prev + (c * dt)**2 * (
        (np.roll(u, 1, axis=1) - 2 * u + np.roll(u, -1, axis=1)) / dx**2 +
        (np.roll(u, 1, axis=0) - 2 * u + np.roll(u, -1, axis=0)) / dy**2)

    #Condiciones de frontera de Dirichlet
    u_next[0, :] = 0
    u_next[-1, :] = 0
    u_next[:, 0] = 0
    u_next[:, -1] = 0


    u_next[obstacle == 1] = 0


    u_prev = u
    u = u_next



fig, ax = plt.subplots()


im = ax.imshow(u, cmap='inferno', vmin=-0.5, vmax=0.5, extent=[0, 2, 0, 1], origin='lower', animated=True)


ax.plot([1, 1], [0.6, 1], color="w", linewidth=10)
ax.plot([1, 1], [0, 0.4], color="w", linewidth=10)

def update(*args):
    global u, u_prev, u_next

    u_next = 2 * u - u_prev + (c * dt)**2 * (
        (np.roll(u, 1, axis=1) - 2 * u + np.roll(u, -1, axis=1)) / dx**2 +
        (np.roll(u, 1, axis=0) - 2 * u + np.roll(u, -1, axis=0)) / dy**2)

    u_next[0, :] = 0
    u_next[-1, :] = 0
    u_next[:, 0] = 0
    u_next[:, -1] = 0
    u_next[obstacle == 1] = 0

    u_prev = u
    u = u_next

    im.set_array(u)
    return [im]

anim = animation.FuncAnimation(fig, update, frames=nt, interval=20, blit=True)
plt.show()

anim.save("bidimensional.gif",fps=30)
anim

for n in range(1, nt):
    u_next = 2 * u - u_prev + (c * dt)**2 * (
        (np.roll(u, 1, axis=1) - 2 * u + np.roll(u, -1, axis=1)) / dx**2 +
        (np.roll(u, 1, axis=0) - 2 * u + np.roll(u, -1, axis=0)) / dy**2)

    # Condiciones de frontera de Neumann
    u_next[0, :] = u_next[1, :]
    u_next[-1, :] = u_next[-2, :]
    u_next[:, 0] = u_next[:, 1]
    u_next[:, -1] = u_next[:, -2]


    u_next[obstacle == 1] = 0


    u_prev = u
    u = u_next


fig, ax = plt.subplots()


im = ax.imshow(u, cmap='inferno', vmin=-0.5, vmax=0.5, extent=[0, 2, 0, 1], origin='lower', animated=True)


ax.plot([1, 1], [0.6, 1], color="w", linewidth=10)
ax.plot([1, 1], [0, 0.4], color="w", linewidth=10)

def update(*args):
    global u, u_prev, u_next

    u_next = 2 * u - u_prev + (c * dt)**2 * (
        (np.roll(u, 1, axis=1) - 2 * u + np.roll(u, -1, axis=1)) / dx**2 +
        (np.roll(u, 1, axis=0) - 2 * u + np.roll(u, -1, axis=0)) / dy**2)

    u_next[0, :] = u_next[1, :]
    u_next[-1, :] = u_next[-2, :]
    u_next[:, 0] = u_next[:, 1]
    u_next[:, -1] = u_next[:, -2]

    u_next[obstacle == 1] = 0

    u_prev = u
    u = u_next

    im.set_array(u)
    return [im]

anima = animation.FuncAnimation(fig, update, frames=nt, interval=20, blit=True)
plt.show()

anima.save("bidimensional2.gif",fps=30)
anima