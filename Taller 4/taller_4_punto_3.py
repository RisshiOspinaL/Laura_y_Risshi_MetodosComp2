# -*- coding: utf-8 -*-
"""Taller 4 punto 3

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1baAiWXbRWLs71kRhY3gANiZ0g60E86Qr

3) Ondas no lineales, plasma y fluidos (1.5pt)
Una versiÃ³n exageradamente simplificada de un plasma confinado magnÃ©ticamente en un toroide, como
los reactores de fusiÃ³n nuclear tipo Tokamak, se puede modelar usando la ecuaciÃ³n de Korteweg-De
Vries (KdV), una de las pocas ecuaciones fundamentales de tercer orden:
ğœ•ğ‘¡ğœ“ + ğœ“ ğœ•ğ‘¥ğœ“ + ğ›¼
2ğœ•
3
ğ‘¥ğœ“ = 0
Este ğœ“ corresponde a la intensidad de ondas acÃºsticas en un plasma con colisiones despreciables, pero
tambiÃ©n puede interpretarse como ondas superficiales en un fluido de poca profundidad.
3.1) SimulaciÃ³n
Simule usando el esquema de diferencias finitas presentado en el artÃ­culo Â«Interaction of â€œSolitonsâ€ in
a Collisionless Plasma and the Recurrence of Initial StatesÂ»Â¹ que puede encontrar en bloque neÃ³n.
Â¹N. J. Zabusky and M. D. Kruskal, Phys. Rev. Lett. 15, 240; sÃ³lo nos interesa la nota 6.
Use ğ›¼ = 0.022, ğ‘¥ âˆˆ (0, 2], condiciones de frontera periÃ³dicas en ğ‘¥, es decir ğœ“(ğ‘¡, ğ‘¥) = ğœ“(ğ‘¡, ğ‘¥ + 2), y
condiciones iniciales ğœ“(0, ğ‘¥) = cos(ğœ‹ğ‘¥). Simule hasta encontrar algÃºn comportamiento interesante, y
describa sus resultados. Presente una animaciÃ³n en video de la evoluciÃ³n temporal del sistema.
3.2) Â¿QuÃ© pasa si aumenta o disminuye el valor de ğ›¼?
3.3) EvalÃºe las siguientes cantidades funciÃ³n del tiempo:
masa = âˆ« ğœ“ dğ‘¥ momento = âˆ« ğœ“
2 dğ‘¥ energÃ­a = âˆ«(
1
3
ğœ“
3 âˆ’ (ğ›¼ ğœ•ğ‘¥ğœ“)
2) dğ‘¥
DeberÃ­an ser cantidades conservadas. Â¿Cambian significativamente?
Incluya en su animaciÃ³n otro grÃ¡fico con la transformada de Fourier de ğœ“ en cada tiempo, en escala
log-log, y describa el comportamiento que observa.
"""

import numpy as np
import matplotlib.pyplot as plt
from tqdm.notebook import tqdm
from matplotlib.animation import FuncAnimation
plt.rcParams["animation.html"] = "jshtml"

# ParÃ¡metros
L = 2.0            # Longitud del dominio
N = 256            # NÃºmero de puntos espaciales
alpha = 0.022      # Coeficiente de dispersiÃ³n
dx = L / (N - 1)   # TamaÃ±o del paso espacial
dt = 0.01          # TamaÃ±o del paso temporal
T_max = 10         # Tiempo mÃ¡ximo de simulaciÃ³n

x = np.linspace(0, L, N)

psi = np.cos(np.pi * x)

psi_history = np.zeros((int(T_max / dt), N))
psi_history[0, :] = psi

for t in range(1, int(T_max / dt)):
    psi_new = np.zeros_like(psi)
    for i in range(1, N-1):

        psi_new[i] = (psi[i] - dt * (psi[i] * (psi[i+1] - psi[i-1]) / (2 * dx) +
                                      alpha / 2 * (psi[i+1] - 2 * psi[i] + psi[i-1]) / (dx ** 3)))


    psi_new[0] = psi_new[N-1] = psi_new[1]
    psi = psi_new
    psi_history[t, :] = psi

fig, ax = plt.subplots()
line, = ax.plot(x, psi_history[0, :], 'b-')
ax.set_ylim(-1.5, 1.5)
ax.set_title('EvoluciÃ³n de la onda solitaria')
ax.set_xlabel('x')
ax.set_ylabel('Ïˆ(t, x)')

def update(frame):
    line.set_ydata(psi_history[frame, :])
    return line,

ani = FuncAnimation(fig, update, frames=int(T_max/dt), blit=True, repeat=False)
plt.show()

ani.save("tercer.mp4")
ani

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from numpy.fft import fft, fftfreq
plt.rcParams["animation.html"] = "jshtml"

# ParÃ¡metros
L = 2.0            # Longitud del dominio
N = 256            # NÃºmero de puntos espaciales
alpha = 0.022      # Coeficiente de dispersiÃ³n
dx = L / (N - 1)   # TamaÃ±o del paso espacial
dt = 0.01          # TamaÃ±o del paso temporal
T_max = 10         # Tiempo mÃ¡ximo de simulaciÃ³n

x = np.linspace(0, L, N)

psi = np.cos(np.pi * x)

num_steps = int(T_max / dt)
psi_history = np.zeros((num_steps, N))
psi_history[0, :] = psi

for t in range(1, num_steps):
    psi_new = np.zeros_like(psi)
    for i in range(1, N-1):

        psi_new[i] = (psi[i] - dt * (psi[i] * (psi[i+1] - psi[i-1]) / (2 * dx) +
                                      alpha / 2 * (psi[i+1] - 2 * psi[i] + psi[i-1]) / (dx ** 3)))


    psi_new[0] = psi_new[N-1] = psi_new[1]
    psi = psi_new
    psi_history[t, :] = psi

fft_history = np.abs(fft(psi_history, axis=1))
frequencies = fftfreq(N, d=dx)

fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(10, 6))

im1 = ax1.imshow(psi_history.T, aspect='auto', extent=[0, T_max, x.min(), x.max()], cmap='magma')
ax1.set_title('Ãngulo x vs Intensidad')
ax1.set_xlabel('Tiempo')
ax1.set_ylabel('Ãngulo x')
fig.colorbar(im1, ax=ax1, label="Intensidad")


im2 = ax2.imshow(np.log10(fft_history.T + 1e-10), aspect='auto', extent=[0, T_max, frequencies.min(), frequencies.max()], cmap='viridis')
ax2.set_title('Frecuencia vs Tiempo')
ax2.set_xlabel('Tiempo')
ax2.set_ylabel('Frecuencia')
fig.colorbar(im2, ax=ax2, label="Abs(Transformada)")


def update(frame):
    im1.set_data(psi_history[:frame].T)
    im2.set_data(np.log10(fft_history[:frame].T + 1e-10))
    return im1, im2


ani = FuncAnimation(fig, update, frames=num_steps, blit=False, interval=50)


plt.tight_layout()
plt.show()


ani.save("evolucion_onda_y_frecuencia.mp4", writer="ffmpeg")